---
title: "Tarea 5. Diferenciación e integración numérica."
author: "Mi nombre"
format: 
  html:
    grid: 
      body-width: 1000px
editor: visual
jupyter: python3
---

Importamos packages y funciones necesarias:

```{python}
#| code-fold: true

import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.interpolate import lagrange
from numpy.polynomial.polynomial import Polynomial
from scipy.interpolate import CubicSpline

import plotly.graph_objects as go
from scipy.differentiate import derivative
import numdifftools as nd
from scipy.stats import norm
from scipy import integrate

```

# Ejercicio 1.

Para cada una de las siguientes funciones:

-   Realiza la respectiva gráfica en el intervalo dado.

-   Compara las gráficas de las derivadas aproximadas de la función `derivative` de `Scipy`, con dos tamaños de paso utilizando la función `nd.Derivative` y la derivada *exacta* en tal intervalo.

-   Compara las gráficas de las segundas derivadas aproximadas con dos tamaños de paso utilizando la función `nd.Derivative` y la segunda derivada *exacta* en tal intervalo.

-   Realiza las gráficas de los errores absolutos en cada caso.

a)  $f(x)=e^{2x}-cos 2x$, $x\in [0,2]$

```{python}
f = lambda x: np.exp(2*x) - np.cos(2*x)
a, b = 0, 2
x_values = np.linspace(a, b, 300)

plt.figure(figsize=(9, 6))
plt.plot(x_values, f(x_values), color='darkcyan', linewidth=2, linestyle='--', label=r'$f(x) = e^{2x} - \cos(2x)$')
plt.title('Gráfica de la función $f(x)$ en el intervalo [0, 2]', fontsize=16, fontweight='semibold')
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.grid(True, linestyle=':', alpha=0.7)
plt.legend(loc='upper left', fontsize=12)
plt.tight_layout()
plt.show()

```

Primera dx/y

```{python}
df = lambda x: 2*np.exp(2*x) + 2*np.sin(2*x)
df_1 = nd.Derivative(f, step=0.05, method='central', order=2)  # paso cambiado para diferencia visual
df_2 = nd.Derivative(f, step=0.3, method='central', order=2)

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values, y=df(x_values),
    mode='lines',
    name='Derivada exacta',
    line=dict(color='darkslateblue', width=4, dash='solid')
))

fig.add_trace(go.Scatter(
    x=x_values, y=df_1(x_values),
    mode='lines',
    name='Aprox. h=0.05',
    line=dict(color='mediumseagreen', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values, y=df_2(x_values),
    mode='lines',
    name='Aprox. h=0.3',
    line=dict(color='coral', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values, y=derivative(f, x_values),
    mode='lines',
    name='SciPy',
    line=dict(color='orchid', width=3, dash='dashdot')
))

fig.update_layout(
    title="Comparación de la Primera Derivada y Aproximaciones Numéricas",
    xaxis_title="x",
    yaxis_title="Derivada",
    template="plotly_dark",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(0,0,0,0.3)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Segunda dx/y

```{python}
{python}
#| code-fold: true
#| warning: false

dderf = lambda x: 4*np.exp(2*x) + 4*np.cos(2*x)

ddf_25 = nd.Derivative(f, step=0.25, method='central', order=2, n = 2)
ddf_005 = nd.Derivative(f, step=0.05, method='central', order=2, n = 2)

fig = go.Figure()
fig.add_trace(go.Scatter(x= x_values, y= ddf_25(x_values), mode='lines', name='h=0.25', line=dict(color='royalblue', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= ddf_005(x_values), mode='lines', name='h=0.05', line=dict(color='teal', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= dderf(x_values), mode='lines', name='2da. derivada', line=dict(color='goldenrod', width=1)))

fig.update_layout(
    title="Gráfica de aproximación de la 2da derivada",
    xaxis_title="x",
    yaxis_title="y",
    template="plotly_white",
    width = 768,
    height = 576
)

fig.show()
```

Grafica de errores.

```{python}
f = lambda x: np.exp(2*x) - np.cos(2*x)

x_values = np.linspace(0, 2, 300)

ddf_exact = lambda x: 4*np.exp(2*x) + 4*np.cos(2*x)
ddf_1 = nd.Derivative(f, step=0.1, method='central', order=2, n=2)
ddf_2 = nd.Derivative(f, step=0.25, method='central', order=2, n=2)

error_h1 = np.abs(ddf_exact(x_values) - ddf_1(x_values))
error_h2 = np.abs(ddf_exact(x_values) - ddf_2(x_values))

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h2,
    mode='lines',
    name='Error h=0.25',
    line=dict(color='mediumorchid', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h1,
    mode='lines',
    name='Error h=0.1',
    line=dict(color='darkorange', width=2, dash='dot')
))

fig.update_layout(
    title="Errores Absolutos en la Aproximación de la 2da Derivada",
    xaxis_title="x",
    yaxis_title="Error absoluto",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Paso h", bgcolor='rgba(255,255,255,0.8)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

b $f(x)=log(x+2)-(x+1)^2$, $x\in [0,5]$

```{python}
f = lambda x: np.log(x + 2) - (x + 1)**2
x_values = np.linspace(0, 5, 500)

plt.figure(figsize=(9, 6))
plt.plot(x_values, f(x_values), color='mediumslateblue', linewidth=2, linestyle='-.', label=r'$f(x) = \log(x+2) - (x+1)^2$')
plt.title('Gráfica de la función $f(x)$ en el intervalo [0, 5]', fontsize=16, fontweight='semibold')
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.grid(True, linestyle=':', alpha=0.7)
plt.legend(loc='upper right', fontsize=12)
plt.tight_layout()
plt.show()
```

Primera dx/Y

```{python}
f = lambda x: np.log(x + 2) - (x + 1)**2
derf = lambda x: 1/(x + 2) - 2*(x + 1)

x_values = np.linspace(0, 5, 500)

df_1 = nd.Derivative(f, step=0.1, method='central', order=2)
df_25 = nd.Derivative(f, step=0.25, method='central', order=2)

df_scipy = lambda x: derivative(f, x, dx=1e-6)

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_1(x_values),
    mode='lines',
    name='Aprox. h=0.1',
    line=dict(color='darkcyan', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_25(x_values),
    mode='lines',
    name='Aprox. h=0.25',
    line=dict(color='royalblue', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_scipy(x_values),
    mode='lines',
    name='SciPy',
    line=dict(color='aqua', width=3, dash='dashdot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=derf(x_values),
    mode='lines',
    name='Derivada exacta',
    line=dict(color='goldenrod', width=3, dash='solid')
))

fig.update_layout(
    title="Comparación de Aproximaciones de la Primera Derivada",
    xaxis_title="x",
    yaxis_title="Derivada",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.8)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Segunda dx/Y

```{python}
f = lambda x: np.log(x + 2) - (x + 1)**2

dderf = lambda x: -(1 / (x + 2)**2) - 2 * np.ones_like(x)

x_values = np.linspace(0, 5, 500)

ddf_1 = nd.Derivative(f, step=0.1, method='central', order=2, n=2)
ddf_25 = nd.Derivative(f, step=0.25, method='central', order=2, n=2)

# Graficar las derivadas
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=ddf_1(x_values),
    mode='lines',
    name='Aprox. h=0.1',
    line=dict(color='darkcyan', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=ddf_25(x_values),
    mode='lines',
    name='Aprox. h=0.25',
    line=dict(color='mediumvioletred', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=dderf(x_values),
    mode='lines',
    name='2da derivada exacta',
    line=dict(color='goldenrod', width=3, dash='solid')
))

fig.update_layout(
    title="Comparación de la Segunda Derivada y Aproximaciones Numéricas",
    xaxis_title="x",
    yaxis_title="Valor de la Segunda Derivada",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.8)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Grafica de errores

```{python}
f = lambda x: np.log(x + 2) - (x + 1)**2
dderf = lambda x: -(1 / (x + 2)**2) - 2 * np.ones_like(x)

x_values = np.linspace(0, 5, 500)


ddf_1 = nd.Derivative(f, step=0.1, method='central', order=2, n=2)
ddf_25 = nd.Derivative(f, step=0.25, method='central', order=2, n=2)

error_h1 = np.abs(dderf(x_values) - ddf_1(x_values))
error_h25 = np.abs(dderf(x_values) - ddf_25(x_values))

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h1,
    mode='lines',
    name='Error h=0.1',
    line=dict(color='mediumvioletred', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h25,
    mode='lines',
    name='Error h=0.25',
    line=dict(color='darkcyan', width=2, dash='dot')
))

fig.update_layout(
    title="Errores Absolutos en la Aproximación de la Segunda Derivada",
    xaxis_title="x",
    yaxis_title="Error absoluto",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Paso h", bgcolor='rgba(255,255,255,0.8)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

c $f(x)=\sqrt{x} sen(x^2)$, $x\in [0,\pi]$

```{python}
f = lambda x: np.sqrt(x) * np.sin(x**2)
a, b = 0, np.pi
x_values = np.linspace(a, b, 500)

plt.figure(figsize=(9, 6))
plt.plot(x_values, f(x_values), color='mediumseagreen', linewidth=2, linestyle='--', label=r'$f(x) = \sqrt{x} \sin(x^2)$')
plt.title('Gráfica de la función $f(x)$ en el intervalo $[0, \pi]$', fontsize=16, fontweight='semibold')
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.grid(True, linestyle=':', alpha=0.7)
plt.legend(loc='upper right', fontsize=12)
plt.tight_layout()
plt.show()
```

Primera dx/y

```{python}
f = lambda x: np.sqrt(x) * np.sin(x**2)

derf = lambda x: 2 * x * np.sqrt(x) * np.cos(x**2) + (np.sin(x**2) / 2) * (1 / np.sqrt(x))

x_values = np.linspace(0.01, np.pi, 500)  # evitar x=0 para sqrt(x)

# Derivadas numéricas con distintos pasos h
df_01 = nd.Derivative(f, step=0.1, method='central', order=2)
df_005 = nd.Derivative(f, step=0.05, method='central', order=2)

# Derivada con scipy (primera derivada)
df_scipy = lambda x: derivative(f, x, dx=1e-6)

# Crear figura
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_01(x_values),
    mode='lines',
    name='Aprox. h=0.1',
    line=dict(color='darkslategray', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_005(x_values),
    mode='lines',
    name='Aprox. h=0.05',
    line=dict(color='mediumvioletred', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_scipy(x_values),
    mode='lines',
    name='SciPy',
    line=dict(color='deepskyblue', width=3, dash='dashdot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=derf(x_values),
    mode='lines',
    name='Derivada exacta',
    line=dict(color='goldenrod', width=3, dash='solid')
))

fig.update_layout(
    title="Comparación de Aproximaciones de la Primera Derivada",
    xaxis_title="x",
    yaxis_title="Derivada",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Segunda dx/y

```{python}
f = lambda x: np.sqrt(x) * np.sin(x**2)

# Segunda derivada exacta analítica
dderf = lambda x: 4 * np.sqrt(x) * np.cos(x**2) - np.sin(x**2) * (4 * x**2 * np.sqrt(x) + 1 / (4 * x * np.sqrt(x)))

x_values = np.linspace(0.01, np.pi, 500)


ddf_01 = nd.Derivative(f, step=0.1, method='central', order=2, n=2)
ddf_005 = nd.Derivative(f, step=0.05, method='central', order=2, n=2)

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=ddf_01(x_values),
    mode='lines',
    name='Aprox. h=0.1',
    line=dict(color='darkorange', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=ddf_005(x_values),
    mode='lines',
    name='Aprox. h=0.05',
    line=dict(color='mediumseagreen', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=dderf(x_values),
    mode='lines',
    name='2da derivada exacta',
    line=dict(color='goldenrod', width=3, dash='solid')
))

fig.update_layout(
    title="Comparación de la Segunda Derivada y Aproximaciones Numéricas",
    xaxis_title="x",
    yaxis_title="Valor de la Segunda Derivada",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Grafica de errores

```{python}
f = lambda x: np.sqrt(x) * np.sin(x**2)

# Segunda derivada exacta analítica
dderf = lambda x: 4 * np.sqrt(x) * np.cos(x**2) - np.sin(x**2) * (4 * x**2 * np.sqrt(x) + 1 / (4 * x * np.sqrt(x)))

# Valores para evaluar (evitando 0 para evitar división por cero)
x_values = np.linspace(0.01, np.pi, 500)

# Derivadas numéricas de segundo orden con distintos pasos h
ddf_05 = nd.Derivative(f, step=0.05, method='central', order=2, n=2)
ddf_125 = nd.Derivative(f, step=0.125, method='central', order=2, n=2)

# Calcular errores absolutos
error_h005 = np.abs(dderf(x_values) - ddf_05(x_values))
error_h125 = np.abs(dderf(x_values) - ddf_125(x_values))

# Graficar errores
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h125,
    mode='lines',
    name='Error h=0.125',
    line=dict(color='mediumslateblue', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h005,
    mode='lines',
    name='Error h=0.05',
    line=dict(color='darkorange', width=2, dash='dot')
))

fig.update_layout(
    title="Errores Absolutos en la Aproximación de la Segunda Derivada",
    xaxis_title="x",
    yaxis_title="Error absoluto",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Paso h", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Gráfica de la función.

```{python}
#| code-fold: true
#| fig-align: 'center'


f = lambda x: np.sqrt(x)*np.sin(x**2)

x_values = np.linspace(0, np.pi, 200)

plt.figure(figsize=(8,6))
plt.plot(x_values,  f(x_values), color = "darkred", linewidth=1.5)
plt.grid()
plt.show()
```

Derivada : $f'(x)= 2x\sqrt{x}\,cos(x^2)+\frac{sen(x^2)}{2\sqrt{x}}$. Aproximaciones con dos tamaños de paso $h=0.05$ y $h=0.1$

```{python}
#| code-fold: true
#| warning: false
#| message: false

derf = lambda x: 2* x * np.sqrt(x) * np.cos(x**2)+ (np.sin(x**2)/2) * (1/np.sqrt(x))


df_01 = nd.Derivative(f, step=0.1, method='central', order=2)
df_005 = nd.Derivative(f, step=0.05, method='central', order=2)


fig = go.Figure()

fig.add_trace(go.Scatter(x= x_values, y= df_01(x_values), mode='lines', name='h=0.1', line=dict(color='teal', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= df_005(x_values), mode='lines', name='h=0.05', line=dict(color='royalblue', width=1)))
# Aproximación de la derivada con derivative de Scipy
fig.add_trace(go.Scatter(x= x_values, y= derivative(f, x_values).df, mode='lines', name='SciPy', line=dict(color='aqua', width=2)))
# Derivada "exacta"
fig.add_trace(go.Scatter(x= x_values, y= derf(x_values), mode='lines', name='Derivada', line=dict(color='goldenrod', width=1)))

fig.update_layout(
    title="Gráfica de aproximación de las derivadas",
    xaxis_title="x",
    yaxis_title="y",
    template="plotly_white",
    width = 768,
    height = 576
)

fig.show()
```

Gráfica del valor absoluto de los errores para las aproximaciones de la primera derivada.

```{python}
#| code-fold: true
#| warning: false


fig = go.Figure()

fig.add_trace(go.Scatter(x= x_values, y= abs(derf(x_values)-df_01(x_values)), mode='lines', name='h=0.1', line=dict(color='royalblue', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= abs(derf(x_values)-df_005(x_values)), mode='lines', name='h=0.05', line=dict(color='teal', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= abs(derf(x_values)-derivative(f, x_values).df), mode='lines', name='SciPy', line=dict(color='aqua', width=2)))

fig.update_layout(
    title="Gráfica de errores",
    xaxis_title="x",
    yaxis_title="y",
    template="plotly_white",
    width = 768,
    height = 576
)

fig.show()
```

Segunda derivada: $f''(x)= 4 \sqrt{x}\, cos(x^2)-sen(x^2)\left(4 x^2 \sqrt{x}+\frac{1}{4x\sqrt{x}} \right)$. Aproximaciones con $h=0.05$ y $h=0.1$

```{python}
#| code-fold: true
#| warning: false

dderf = lambda x: 4* np.sqrt(x) * np.cos(x**2) -np.sin(x**2) *(4* x **2 * np.sqrt(x)+1/(4*x*np.sqrt(x)))

# Funciones de numdifftools para la segunda derivada
ddf_01 = nd.Derivative(f, step=0.1, method='central', order=2, n = 2)
ddf_005 = nd.Derivative(f, step=0.05, method='central', order=2, n = 2)

fig = go.Figure()
fig.add_trace(go.Scatter(x= x_values, y= ddf_01(x_values), mode='lines', name='h=0.1', line=dict(color='royalblue', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= ddf_005(x_values), mode='lines', name='h=0.05', line=dict(color='teal', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= dderf(x_values), mode='lines', name='2da. derivada', line=dict(color='goldenrod', width=1)))

fig.update_layout(
    title="Gráfica de aproximación de la 2da derivada",
    xaxis_title="x",
    yaxis_title="y",
    template="plotly_white",
    width = 768,
    height = 576
)

fig.show()

```

Gráfica del valor absoluto de los errores para las aproximaciones de la segunda derivada.

```{python}
#| code-fold: true
#| warning: false


fig = go.Figure()

fig.add_trace(go.Scatter(x= x_values, y= abs(dderf(x_values)-ddf_01(x_values)), mode='lines', name='h=0.1', line=dict(color='royalblue', width=1)))
fig.add_trace(go.Scatter(x= x_values, y= abs(dderf(x_values)-ddf_005(x_values)), mode='lines', name='h=0.05', line=dict(color='teal', width=1)))

fig.update_layout(
    title="Gráfica de errores segunda derivada",
    xaxis_title="x",
    yaxis_title="y",
    template="plotly_white",
    width = 768,
    height = 576
)

fig.show()
```

d)  $f(x)=(cos\,3x)^2-e^{2x}$, $x\in [0,\pi/2]$

```{python}

f = lambda x: (np.cos(3*x))**2 - np.exp(2*x)
x_values = np.linspace(0, np.pi/2, 500)

plt.figure(figsize=(9, 6))
plt.plot(x_values, f(x_values), color='indigo', linewidth=2, linestyle='-.', label=r'$f(x) = \cos^2(3x) - e^{2x}$')
plt.title('Gráfica de la función $f(x)$ en el intervalo $[0, \pi/2]$', fontsize=16, fontweight='semibold')
plt.xlabel('x', fontsize=14)
plt.ylabel('f(x)', fontsize=14)
plt.grid(True, linestyle=':', alpha=0.7)
plt.legend(loc='upper right', fontsize=12)
plt.tight_layout()
plt.show()
```

primera dx/y

```{python}
f = lambda x: (np.cos(3*x))**2 - np.exp(2*x)

derf = lambda x: -3 * np.sin(6*x) - 2 * np.exp(2*x)

x_values = np.linspace(0, np.pi/2, 500)

df_125 = nd.Derivative(f, step=0.125, method='central', order=2)
df_05 = nd.Derivative(f, step=0.05, method='central', order=2)

df_scipy = lambda x: derivative(f, x, dx=1e-6)

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_125(x_values),
    mode='lines',
    name='Aprox. h=0.125',
    line=dict(color='darkcyan', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_05(x_values),
    mode='lines',
    name='Aprox. h=0.05',
    line=dict(color='mediumvioletred', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=df_scipy(x_values),
    mode='lines',
    name='SciPy',
    line=dict(color='deepskyblue', width=3, dash='dashdot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=derf(x_values),
    mode='lines',
    name='Derivada exacta',
    line=dict(color='goldenrod', width=3, dash='solid')
))

fig.update_layout(
    title="Comparación de Aproximaciones de la Primera Derivada",
    xaxis_title="x",
    yaxis_title="Derivada",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

Grafica de errores

```{python}
f = lambda x: (np.cos(3*x))**2 - np.exp(2*x)

derf = lambda x: -3 * np.sin(6*x) - 2 * np.exp(2*x)

x_values = np.linspace(0, np.pi/2, 500)

df_125 = nd.Derivative(f, step=0.125, method='central', order=2)
df_05 = nd.Derivative(f, step=0.05, method='central', order=2)

df_scipy = derivative(f, x_values, dx=1e-6)

error_h125 = np.abs(derf(x_values) - df_125(x_values))
error_h05 = np.abs(derf(x_values) - df_05(x_values))
error_scipy = np.abs(derf(x_values) - df_scipy)

fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h125,
    mode='lines',
    name='Error h=0.125',
    line=dict(color='mediumslateblue', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_h05,
    mode='lines',
    name='Error h=0.05',
    line=dict(color='darkorange', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=error_scipy,
    mode='lines',
    name='Error SciPy',
    line=dict(color='teal', width=3, dash='dashdot')
))

fig.update_layout(
    title="Errores Absolutos en la Aproximación de la Primera Derivada",
    xaxis_title="x",
    yaxis_title="Error absoluto",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

segunda dx/y

```{python}
f = lambda x: (np.cos(3*x))**2 - np.exp(2*x)

# Segunda derivada exacta analítica
dderf = lambda x: -18 * np.cos(6*x) - 4 * np.exp(2*x)

# Valores para evaluar
x_values = np.linspace(0, np.pi/2, 500)

# Derivadas numéricas de segundo orden con distintos pasos h
ddf_125 = nd.Derivative(f, step=0.125, method='central', order=2, n=2)
ddf_005 = nd.Derivative(f, step=0.05, method='central', order=2, n=2)

# Crear figura
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=ddf_125(x_values),
    mode='lines',
    name='Aprox. h=0.125',
    line=dict(color='royalblue', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=ddf_005(x_values),
    mode='lines',
    name='Aprox. h=0.05',
    line=dict(color='teal', width=2, dash='dot')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=dderf(x_values),
    mode='lines',
    name='2da derivada exacta',
    line=dict(color='goldenrod', width=3, dash='solid')
))

fig.update_layout(
    title="Comparación de la Segunda Derivada y Aproximaciones Numéricas",
    xaxis_title="x",
    yaxis_title="Valor de la Segunda Derivada",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Métodos", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

grafica de errores

```{python}
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x_values,
    y=np.abs(dderf(x_values) - ddf_125(x_values)),
    mode='lines',
    name='Error h=0.125',
    line=dict(color='royalblue', width=2, dash='dash')
))

fig.add_trace(go.Scatter(
    x=x_values,
    y=np.abs(dderf(x_values) - ddf_005(x_values)),
    mode='lines',
    name='Error h=0.05',
    line=dict(color='teal', width=2, dash='dot')
))

fig.update_layout(
    title="Errores Absolutos en la Aproximación de la Segunda Derivada",
    xaxis_title="x",
    yaxis_title="Error absoluto",
    template="plotly_white",
    width=800,
    height=600,
    legend=dict(title="Paso h", bgcolor='rgba(255,255,255,0.85)', bordercolor='LightGray', borderwidth=1)
)

fig.show()
```

# Ejericicio 2

Aproximar las siguientes integrales con la función `integrate.quad` (de SciPy) y con el método de Montecarlo, en cada caso hacer una gráfica de la función e indicar el área bajo la curva.

a)  

\begin{equation}
\int_0^1 e^{-x^2}\,dx
\end{equation}

b)  

\begin{equation}
\int_0^\pi sen(x^2)\,dx
\end{equation}

Gráfica de la función y *área bajo la curva*.

```{python}
#| code-fold: true
#| fig-align: 'center'

f= lambda x: np.sin(x ** 2)
  
a = 0
b = np.pi

x_values = np.linspace(a, b, 100)

plt.figure(figsize=(8,6))
plt.plot(x_values,f(x_values), label="Función")
plt.fill_between(np.linspace(a,b, 100), y1=0, y2=f(np.linspace(a,b, 100)), color="green", alpha=0.5)
plt.grid()
plt.legend()
#plt.axis('square')
plt.show()
```

**Aproximación de la integral.**

```{python}
#| code-fold: true

integral = integrate.quad(f, a, b)
print(f'La aproximación de la integral es: {integral[0]}, con un error aproximado de {integral[1]}')
```

**Aproximación de la integral por el método de Montecarlo.**

```{python}
#| code-fold: true
#| fig-align: 'center'

N =500000

ymax = 1
ymin = -1

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = np.abs(y) <= abs(f(x))
puntos_in = puntos_in * np.sign(y)== np.sign(f(x))
puntos_in_positivo = puntos_in *(1 == np.sign(f(x)))
puntos_in_negativo = puntos_in *(-1 == np.sign(f(x)))

puntos_out = ~ puntos_in
puntos_out_positivo = puntos_out * (1 == np.sign(y))
puntos_out_negativo = puntos_out * (-1 == np.sign(y))



x_values = np.linspace(a, b, 100)

plt.figure(figsize=(8,6))

plt.plot(x[puntos_in_positivo], y[puntos_in_positivo], 'o', color="green", label= "Puntos in +", alpha=0.5, markersize=2.5)
plt.plot(x[puntos_in_negativo], y[puntos_in_negativo], 'o', color="red", label= "Puntos in -", alpha=0.5, markersize=2.5)
plt.plot(x[puntos_out_positivo], y[puntos_out_positivo], 'o', color="blue", label= "Puntos out +", alpha=0.5, markersize=2.5)
plt.plot(x[puntos_out_negativo], y[puntos_out_negativo], 'o', color="skyblue", label= "Puntos out -", alpha=0.5, markersize=2.5)
plt.plot(x_values,f(x_values), color= "black", label="Función", linewidth=1.2)
plt.grid()
plt.legend()
plt.show()

  
```

```{python}
#| code-fold: true

integral_montecarlo = (b-a)* ymax *(sum(puntos_in_positivo)/(sum(puntos_in_positivo) + sum(puntos_out_positivo))) + (b-a) * ymin * (sum(puntos_in_negativo)/(sum(puntos_in_negativo) + sum(puntos_out_negativo))) 


print(f'El valor aproximado de la integral con el método de Montecarlo es: {integral_montecarlo}')
```

c)  

\begin{equation}
\int_0^\pi \frac{sen(x)}{x}\,dx
\end{equation}

Gráfica de la función y área bajo la curva.

```{python}
#| code-fold: true
#| fig-align: 'center'
#| warning: false

f= lambda x: np.sin(x)/x
  
a = 0
b = np.pi


x_values = np.linspace(a, b, 100)


plt.figure(figsize=(9,5))
plt.plot(x_values,f(x_values), label="Función")
plt.fill_between(np.linspace(a,b, 100), y1=0, y2=f(np.linspace(a,b, 100)), color="green", alpha=0.5)
plt.grid()
plt.legend()
#plt.axis('square')
plt.show()

  
```

**Aproximación de la integral.**

```{python}
#| code-fold: true

integral = integrate.quad(f, a, b)
print(f'La aproximación de la integral es: {integral[0]}, con un error aproximado de {integral[1]}')
```

**Aproximación de la integral por el método de Montecarlo.**

```{python}
#| code-fold: true
#| fig-align: 'center'
#| warning: false

N =10000

ymax = 1
ymin = 0

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = y <= f(x)
  
x_values = np.linspace(a, b, 100)

plt.figure(figsize=(8,6))
plt.plot(x[puntos_in], y[puntos_in], 'o', color="red", label= "Puntos in", alpha=0.5)
plt.plot(x[~puntos_in], y[~puntos_in], 'o', color="blue", label= "Puntos out", alpha=0.5)
plt.plot(x_values,f(x_values), color= "black", label="Función", linewidth=1.2)
plt.grid()
plt.legend()
plt.show()
```

```{python}
#| code-fold: true

integral_montecarlo = (b-a)* ymax *(sum(puntos_in)/N) 


print(f'El valor aproximado de la integral con el método de Montecarlo es: {integral_montecarlo}')
```

d)  

\begin{equation}
\int_0^\infty e^{-x^2} cos(x) \,dx
\end{equation}

Grafica de dx

```{python}
f = lambda x: np.exp(-x**2) * np.cos(x)
a, b = 0, 10
x_values = np.linspace(a, b, 1000)
y_values = f(x_values)

plt.figure(figsize=(9, 5))
plt.plot(x_values, y_values, color="darkgreen", label="Función")
plt.fill_between(x_values, 0, y_values, color="lightcoral", alpha=0.5)
plt.grid(True)
plt.legend()
plt.show()
```

Aproximacion

```{python}
f = lambda x: np.exp(-x**2) * np.cos(x)
a = 0

integral, error = integrate.quad(f, a, np.inf)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Aproximacion por monte carlo

```{python}
N = 100000
ymax = 1
ymin = 0

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = (np.abs(y) <= np.abs(f(x))) & (np.sign(y) == np.sign(f(x)))
puntos_in_positivo = puntos_in & (np.sign(f(x)) == 1)
puntos_in_negativo = puntos_in & (np.sign(f(x)) == -1)

puntos_out = ~puntos_in
puntos_out_positivo = puntos_out & (np.sign(y) == 1)
puntos_out_negativo = puntos_out & (np.sign(y) == -1)

x_values = np.linspace(a, b, 1000)

plt.figure(figsize=(8,6))
plt.scatter(x[puntos_in_positivo], y[puntos_in_positivo], color="lightpink", label="Puntos in +", alpha=0.5, s=2.5)
plt.scatter(x[puntos_in_negativo], y[puntos_in_negativo], color="red", label="Puntos in -", alpha=0.5, s=2.5)
plt.scatter(x[puntos_out_positivo], y[puntos_out_positivo], color="blue", label="Puntos out +", alpha=0.5, s=2.5)
plt.scatter(x[puntos_out_negativo], y[puntos_out_negativo], color="skyblue", label="Puntos out -", alpha=0.5, s=2.5)
plt.plot(x_values, f(x_values), color="black", label="Función", linewidth=1.2)
plt.grid()
plt.legend()
plt.show()
```

e)  

\begin{equation}
\int_0^1 x^x \,dx
\end{equation}

Grafica dx

```{python}
f = lambda x: x**x
a, b = 0, 1
x_values = np.linspace(a, b, 100)

plt.figure(figsize=(9, 5))
plt.plot(x_values, f(x_values), color="saddlebrown", label="Función")
plt.fill_between(x_values, 0, f(x_values), color="peru", alpha=0.5)
plt.grid(True)
plt.legend()
plt.title("Gráfica de la función $f(x) = x^x$ en [0,1]")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
```

Aproximación

```{python}
integral, error = integrate.quad(f, a, b)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Aproximación Monte carlo

```{python}
N = 100000
ymax = 1
ymin = -1

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = (np.abs(y) <= np.abs(f(x))) & (np.sign(y) == np.sign(f(x)))
puntos_in_positivo = puntos_in & (np.sign(f(x)) == 1)
puntos_in_negativo = puntos_in & (np.sign(f(x)) == -1)

puntos_out = ~puntos_in
puntos_out_positivo = puntos_out & (np.sign(y) == 1)
puntos_out_negativo = puntos_out & (np.sign(y) == -1)

x_values = np.linspace(a, b, 100)

plt.figure(figsize=(8,6))
plt.scatter(x[puntos_in_positivo], y[puntos_in_positivo], color="brown", label="Puntos in +", alpha=0.5, s=2.5)
plt.scatter(x[puntos_in_negativo], y[puntos_in_negativo], color="red", label="Puntos in -", alpha=0.5, s=2.5)
plt.scatter(x[puntos_out_positivo], y[puntos_out_positivo], color="blue", label="Puntos out +", alpha=0.5, s=2.5)
plt.scatter(x[puntos_out_negativo], y[puntos_out_negativo], color="skyblue", label="Puntos out -", alpha=0.5, s=2.5)
plt.plot(x_values, f(x_values), color="black", label="Función", linewidth=1.2)
plt.grid()
plt.legend()
plt.show()
```

f)  

\begin{equation}
\int_1^5 e^{-x^2} x^3 dx
\end{equation}

Grafica dx

```{python}
f = lambda x: np.exp(-x**2) * x**3
a, b = 1, 5
x_values = np.linspace(a, b, 300)

plt.figure(figsize=(8, 6))
plt.plot(x_values, f(x_values), color="forestgreen", label="Función")
plt.fill_between(x_values, 0, f(x_values), color="limegreen", alpha=0.5)
plt.grid(True)
plt.legend()
plt.title("Gráfica de la función $f(x) = e^{-x^2} x^3$ en [1,5]")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()

```

Aproximación

```{python}
integral, error = integrate.quad(f, a, b)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Aproximación Monte carlo

```{python}
N = 10000
ymax = 0.45
ymin = 0

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = y <= f(x)

plt.figure(figsize=(9, 5))
plt.scatter(x[puntos_in], y[puntos_in], color="red", label="Puntos in", alpha=0.6, s=5)
plt.scatter(x[~puntos_in], y[~puntos_in], color="blue", label="Puntos out", alpha=0.6, s=5)
plt.plot(x_values, f(x_values), color="black", label="Función", linewidth=1.5)
plt.grid(True)
plt.legend()
plt.show()
```

g)  

\begin{equation}
\int_0^1 \sqrt{1-x^2} dx
\end{equation}

Gráfica de la función y área bajo la curva

```{python}
#| code-fold: true
#| fig-align: 'center'
#| warning: false

f= lambda x: np.sqrt(1-x**2)
  
a = 0
b = 1

x_values = np.linspace(a, b, 100)

plt.figure(figsize=(8,6))
plt.plot(x_values,f(x_values), label="Función")
plt.fill_between(np.linspace(a,b, 100), y1=0, y2=f(np.linspace(a,b, 100)), color="green", alpha=0.5)
plt.grid()
plt.legend()
plt.axis('square')
plt.show()
```

**Aproximación de la integral.**

```{python}
#| code-fold: true

integral = integrate.quad(f, a, b)
print(f'La aproximación de la integral es: {integral[0]}, con un error aproximado de {integral[1]}')
```

**Aproximación de la integral por el método de Montecarlo.**

```{python}
#| code-fold: true
#| fig-align: 'center'

N =10000

ymax = 1
ymin = 0

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = y <= f(x)

plt.figure(figsize=(8,6))
plt.plot(x[puntos_in], y[puntos_in], 'o', color="red", label= "Puntos in", alpha=0.5)
plt.plot(x[~puntos_in], y[~puntos_in], 'o', color="blue", label= "Puntos out", alpha=0.5)
plt.plot(x_values,f(x_values), color= "black", label="Función", linewidth=1.2)
plt.grid()
plt.legend()
plt.axis('square')
plt.show()
```

```{python}
#| code-fold: true

integral_montecarlo = (b-a)* ymax *(sum(puntos_in)/N) 


print(f'El valor aproximado de la integral con el método de Montecarlo es: {integral_montecarlo}')
```

h)  

\begin{equation}
\int_0^\infty \frac{x}{e^x-1} dx
\end{equation}

Grafica dx

```{python}
f = lambda x: x / (np.exp(x) - 1)
a, b = 0, 10
x_values = np.linspace(a, b, 1000)

plt.figure(figsize=(8, 6))
plt.plot(x_values, f(x_values), color="black", label="Función")
plt.fill_between(x_values, 0, f(x_values), color="aqua", alpha=0.5)
plt.grid(True)
plt.legend()
plt.title("Gráfica de la función $f(x) = \\frac{x}{e^x - 1}$")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.show()
```

Aproximación

```{python}
f = lambda x: x / (np.exp(x) - 1)
a = 0

integral, error = integrate.quad(f, a, np.inf)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Aproximación Monte carlo

```{python}
N = 10000
ymax = 1
ymin = 0

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = y <= f(x)

plt.figure(figsize=(8, 6))
plt.scatter(x[puntos_in], y[puntos_in], color="aqua", label="Puntos in", alpha=0.5, s=10)
plt.scatter(x[~puntos_in], y[~puntos_in], color="blue", label="Puntos out", alpha=0.5, s=10)
plt.plot(x_values, f(x_values), color="black", label="Función", linewidth=1.2)
plt.grid(True)
plt.legend()
plt.show()
```

```{python}
integral_montecarlo = (b - a) * ymax * (sum(puntos_in) / N)
print(f'El valor aproximado de la integral con el método de Montecarlo es: {integral_montecarlo}')
```

i

\begin{equation}
\int_0^1 \frac{1}{\sqrt{x^4+1}} dx
\end{equation}

Grafica dx

```{python}
f = lambda x: 1 / np.sqrt(x**4 + 1)
a, b = 0, 1
x_values = np.linspace(a, b, 300)

plt.figure(figsize=(8, 6))
plt.plot(x_values, f(x_values), label="Función", color="forestgreen")
plt.fill_between(x_values, 0, f(x_values), color="mediumseagreen", alpha=0.5)
plt.grid(True)

ax = plt.gca()
ax.set_aspect('equal')  # Para que la gráfica tenga aspecto cuadrado

plt.legend()
plt.show()

```

Aproximación

```{python}
integral, error = integrate.quad(f, a, b)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Aproximación Monte carlo

```{python}
N = 10000
ymax = 1
ymin = 0

x = np.random.uniform(a, b, N)
y = np.random.uniform(ymin, ymax, N)

puntos_in = y <= f(x)

plt.figure(figsize=(8, 6))
plt.scatter(x[puntos_in], y[puntos_in], color="aqua", label="Puntos in", alpha=0.5, s=10, edgecolor='black', linewidth=0.3)
plt.scatter(x[~puntos_in], y[~puntos_in], color="blue", label="Puntos out", alpha=0.5, s=10, edgecolor='black', linewidth=0.3)
plt.plot(x_values, f(x_values), color="black", label="Función", linewidth=1.2)
plt.grid(True)
plt.legend()
plt.show()
```

```{python}
integral_montecarlo = (b - a) * ymax * (sum(puntos_in) / N)
print(f'El valor aproximado de la integral con el método de Montecarlo es: {integral_montecarlo}')
```

# Ejercicio 3

Aproximar las siguientes integrales dobles y triples, llevar a cabo la gráfica cuando se indique y comparar con el valor *exacto* de la integral.

a)  Realizar gráfica

\begin{equation}
\int_{-1}^{1}\int_1^2 (3y^2-x^2+5) dx dy
\end{equation}

Grafica

```{python}
x = np.linspace(1, 2, 100)
y = np.linspace(-1, 1, 100)
X, Y = np.meshgrid(x, y)
Z = 3 * Y**2 - X**2 + 5

fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y)])

fig.update_layout(
    title="Gráfica de la función $f(x, y) = 3y^2 - x^2 + 5$",
    scene=dict(
        xaxis_title="x",
        yaxis_title="y",
        zaxis_title="f(x, y)"
    ),
    width=700,
    height=600
)

fig.show()
```

Integración

```{python}
x_val = np.array([1, 2])
y_val1 = np.array([-1, -1])
y_val2 = np.array([1, 1])

plt.figure(figsize=(8, 6))
plt.plot(x_val, y_val1, color="rebeccapurple")
plt.plot(x_val, y_val2, color="rebeccapurple")
plt.fill_between(x_val, y_val1, y_val2, color="navy", alpha=0.5)
plt.title("Región de Integración")
plt.grid(True)
plt.show()
```

Aproximación

```{python}
f = lambda y, x: 3*y**2 - x**2 + 5

integral, error = integrate.dblquad(f, 1, 2, lambda x: -1, lambda x: 1)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Error absoluto

```{python}
integral_exacta = 22 / 3
error_absoluto = abs(integral_exacta - integral[0])
print(f'El error absoluto es: {error_absoluto}')
```

b)  

\begin{equation}
\int_{0}^{6}\int_1^5 \sqrt{x+4y} dx dy
\end{equation}

Grafica

```{python}
x = np.linspace(0.5, 6, 150)  # rango más amplio y mayor resolución
y = np.linspace(-1, 7, 150)
X, Y = np.meshgrid(x, y)
Z = np.sqrt(X + 4 * Y)

fig = go.Figure(data=[go.Surface(z=Z, x=X, y=Y, colorscale='Viridis')])

fig.update_layout(
    title="Gráfica de la función $f(x,y) = \sqrt{x + 4y}$ con parámetros ajustados",
    scene=dict(
        xaxis=dict(title="x", range=[0.5, 6]),
        yaxis=dict(title="y", range=[-1, 7]),
        zaxis=dict(title="f(x, y)", range=[0, np.max(Z)])
    ),
    width=800,
    height=700,
    margin=dict(l=65, r=50, b=65, t=90)
)

fig.show()
```

Integración

```{python}
x_val = np.array([1, 5])
y_val1 = np.array([0, 0])
y_val2 = np.array([6, 6])

plt.figure(figsize=(10, 7)) 
plt.plot(x_val, y_val1, color="coral", linewidth=3)
plt.plot(x_val, y_val2, color="coral", linewidth=3)
plt.fill_between(x_val, y_val1, y_val2, color="cor#
plt.title("Región de Integración", fontsize=16, fontweight='bold')  # Título más grande y en negrita
plt.grid(True, linestyle='--', alpha=0.7)  # Grilla con líneas punteadas y más visibles
plt.xlabel("x", fontsize=14)
plt.ylabel("y", fontsize=14)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()
```

Aproximación

```{python}
{python}
#| code-fold: true

f = lambda y, x: np.sqrt(x+4*y)

integral = integrate.dblquad(f, 1, 5, lambda x: 0, lambda x: 6)
print(f'La aproximación de la integral es: {integral[0]}, con un error aproximado de {integral[1]}')
```

Error absoluto

```{python}
{python}
#| code-fold: true

integral_exacta = (1/15)*(841*np.sqrt(29) -25*np.sqrt(5) -3124)
error_absoluto = abs(integral_exacta - integral[0])
print(f'El error absoluto es:{error_absoluto}')
```

c)  

\begin{equation}
\int_{1}^{e}\int_0^{log(x)} x^3 dx dy
\end{equation}

Grafica

```{python}
x_val = np.array([0, np.log(np.e)])
y_val1 = np.array([1, 1])
y_val2 = np.array([np.e, np.e])

plt.figure(figsize=(9, 6))
plt.plot(x_val, y_val1, color="midnightblue", linewidth=2, linestyle='--')
plt.plot(x_val, y_val2, color="midnightblue", linewidth=2, linestyle='--')
plt.fill_between(x_val, y_val1, y_val2, color="cornflowerblue", alpha=0.7)
plt.title("Región de Integración", fontsize=16, fontweight='bold', color='navy')
plt.xlabel("x", fontsize=14, color='navy')
plt.ylabel("y", fontsize=14, color='navy')
plt.grid(True, linestyle=':', linewidth=1, alpha=0.6)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()
```

Integración

```{python}
f = lambda y, x: x**3
a, b = 1, np.exp(1)
g = lambda x: 0
h = lambda x: np.log(x)

integral, error = integrate.dblquad(f, a, b, g, h)
print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Error absoluto

```{python}
{python}
#| code-fold: true

integral_exacta = (3*np.exp(4)+1)/(16)
error_absoluto = abs(integral_exacta - integral[0])
print(f'El error absoluto es:{error_absoluto}')
```

d)  

\begin{equation}
\int\int_D 30ye^x dx dy
\end{equation}

Donde $D\subset \mathbb{R}^2$ es la región en la siguiente gráfica.

```{python}
#| code-fold: true
#| fig-align: 'center'




x_val = np.array([0,4])
y_val1 = np.array([0, 1])
y_val2 = np.array([0, 4])

plt.figure(figsize=(8,6))
plt.plot(x_val, y_val1)
plt.plot(x_val, y_val2)
plt.fill_between(x_val, y1=y_val1, y2=y_val2, color="firebrick", alpha=0.5)
plt.grid()
plt.show()

  
```

**Aproximación de la integral.**

```{python}
#| code-fold: true

f = lambda y, x: 30 * y * np.exp(x)

integral = integrate.dblquad(f, 0, 4, lambda x: x/4, lambda x: x)
print(f'La aproximación de la integral es: {integral[0]}, con un error aproximado de {integral[1]}')
```

En este caso el valor exacto de la integral es $\frac{225}{8} (5e^4-1)$. Se calcula el error absoluto.

```{python}
#| code-fold: true

integral_exacta = 225/8*(5*np.exp(4)-1)
error_absoluto = abs(integral_exacta - integral[0])
print(f'El error absoluto es:{error_absoluto}')
```

e)  

\begin{equation}
\int\int \int_B z e^{x+y} dx\, dy\, dz, \, B=[0,1] \times [0,1] \times [0,1]
\end{equation}

Grafica

```{python}
x_val = np.array([0, 1])
y_val1 = np.array([0, 0])
y_val2 = np.array([1, 1])

plt.figure(figsize=(9, 6))
plt.plot(x_val, y_val1, color="slategray", linewidth=2, linestyle=':')
plt.plot(x_val, y_val2, color="slategray", linewidth=2, linestyle=':')
plt.fill_between(x_val, y_val1, y_val2, color="lightsteelblue", alpha=0.7)
plt.grid(True, linestyle='--', alpha=0.6)
plt.title("Área entre líneas", fontsize=15, fontweight='medium', color='dimgray')
plt.xlabel("x", fontsize=13, color='dimgray')
plt.ylabel("y", fontsize=13, color='dimgray')
plt.xticks(fontsize=11)
plt.yticks(fontsize=11)
plt.show()
```

Aproximación

```{python}
f = lambda z, y, x: z * np.exp(x + y)

lim_x = [0, 1]
lim_y = lambda x: [0, 1]
lim_z = lambda x, y: [0, 1]

integral, error = integrate.tplquad(
    f,
    lim_x[0], lim_x[1],
    lambda x: lim_y(x)[0], lambda x: lim_y(x)[1],
    lambda x, y: lim_z(x, y)[0], lambda x, y: lim_z(x, y)[1]
)

print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Error absoluto

```{python}
#| code-fold: true

integral_exacta = ((-1+np.e)**2)/2
error_absoluto = abs(integral_exacta - integral[0])
print(f'El error absoluto es:{error_absoluto}')
```

f)  

\begin{equation}
\int_0^1 \int_0^x \int_0^y (y+xz) dz\, dy\, dx
\end{equation}

Grafica

```{python}
x_val = np.linspace(0, 1, 100)
y_val1 = np.zeros_like(x_val)
y_val2 = x_val

plt.figure(figsize=(9, 6))
plt.fill_between(x_val, y_val1, y_val2, color="mediumslateblue", alpha=0.6)
plt.plot(x_val, y_val1, color="navy", linewidth=2, linestyle='--')
plt.plot(x_val, y_val2, color="navy", linewidth=2, linestyle='--')
plt.title("Región de Integración", fontsize=16, fontweight='bold', color='darkblue')
plt.xlabel("x", fontsize=14, color='darkblue')
plt.ylabel("y", fontsize=14, color='darkblue')
plt.grid(True, linestyle=':', alpha=0.7)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()
```

Aproximación

```{python}
f = lambda z, y, x: y + x * z

lim_x = [0, 1]
lim_y = lambda x: [0, x]
lim_z = lambda x, y: [0, y]

integral, error = integrate.tplquad(
    f,
    lim_x[0], lim_x[1],
    lambda x: lim_y(x)[0], lambda x: lim_y(x)[1],
    lambda x, y: lim_z(x, y)[0], lambda x, y: lim_z(x, y)[1]
)

print(f'La aproximación de la integral es: {integral}, con un error aproximado de {error}')
```

Error absoluto

```{python}
integral_exacta = 7/60
error_absoluto = abs(integral_exacta - integral[0])
print(f'El error absoluto es: {error_absoluto}')
```

# Ejercicio 4

De [scipy.stats](@https://docs.scipy.org/doc/scipy/reference/stats.html) elige alguna distribución de probabilidad continua, realiza la gráfica y encuentra la probabilidad que la variable aleatoria tome un valor en un intervalo dado. Compara el resultado con el método `cdf`.

Como ejemplo consideraremos la distribución gamma, cuya función de densidad está dada por

\begin{equation}
f(x, a)= \frac{x^{a-1} e^{-x}}{\Gamma (a)}
\end{equation}

Gráficamos la función de densidad con un valor de $a = 1.9$.

```{python}
#| code-fold: true
#| fig-align: 'center'

from scipy.stats import gamma
a = 1.9

x_values = np.linspace(0 , gamma.ppf(0.99, a), 500)

plt.figure(figsize=(8,6))
plt.plot(x_values, gamma.pdf(x_values, a), label="Función de densidad")
plt.grid()
plt.legend()
plt.show()


```

Elegimos el intervalo $[1,3]$ para calcular la integral.

```{python}
#| code-fold: true
#| fig-align: 'center'

a1 = 1
b1 = 3

x_values = np.linspace(0 , gamma.ppf(0.99, a), 500)

plt.figure(figsize=(8,6))
plt.plot(x_values, gamma.pdf(x_values, a), label="Función de densidad")
plt.fill_between(np.linspace(a1,b1, 500), y1=0, y2=gamma.pdf(np.linspace(a1,b1, 500), a), color="green", alpha=0.5)
plt.grid()
plt.legend()
plt.show()


```

Se obtiene la integral con `integrate.quad`

```{python}
#| code-fold: true

integral = integrate.quad(gamma.pdf, a1, b1, args = (a,))

print(f'La aproximación de la integral es: {integral[0]}, con un error aproximado de {integral[1]}')
```

Ahora se obtiene el valor por medio del método `cdf` (cumulative distribution function).

```{python}
gamma.cdf(3, a) - gamma.cdf(1, a)
```
