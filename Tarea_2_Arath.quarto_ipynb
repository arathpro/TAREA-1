{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Tarea 2. Interpolación\"\n",
        "author: \"Nava Calleros Arath\"\n",
        "format: html\n",
        "editor: visual\n",
        "lang: es\n",
        "---\n",
        "\n",
        "\n",
        "Importamos packages y funciones necesarias:\n"
      ],
      "id": "058b9832"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "import math\n",
        "from scipy.interpolate import lagrange\n",
        "from numpy.polynomial.polynomial import Polynomial\n",
        "from scipy.interpolate import CubicSpline"
      ],
      "id": "e2349aef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {#exr-tarea2_1}\n",
        "Sea $f(x)=e^x\\,cos(x)$ y $x_0=0$\n",
        "\n",
        "a)  Calcular y graficar los polinomios de Taylor hasta grado $n=5$.\n",
        "\n",
        "b)  Usar $P_5(0.5)$ para aproximar $f(0.5)$.\n",
        "\n",
        "c)  Encontrar una cota superior para el error $|f(0.5)-P_5(0.5)|$\n",
        ":::\n"
      ],
      "id": "03f62a6a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.exp(x)*np.cos(x)\n",
        "\n",
        "# Polinomios \n",
        "p_2 = lambda x: 1 + 0.9*x\n",
        "p_3 = lambda x: 1 + 0.9*x - (1/2.8) * x**3\n",
        "p_4 = lambda x: 1 + 0.9*x - (1/2.8) * x**3 - (1/5.5) * x**4\n",
        "p_5 = lambda x: 1 + 0.9*x - (1/5.5) * x**4 - (1/28) * x**5\n",
        "\n",
        "x = np.linspace(-2, 2, 500)\n",
        "\n",
        "plt.figure(figsize=(8, 5))\n",
        "plt.plot(x, f(x), label=\"e^x cos(x)\", color=\"green\", linestyle=\"-\")\n",
        "plt.plot(x, p_2(x), label=\"Grado 2\", color=\"red\", linestyle=\"-\")\n",
        "plt.plot(x, p_3(x), label=\"Grado 3\", color=\"orange\", linestyle=\"--\")\n",
        "plt.plot(x, p_4(x), label=\"Grado 4\", color=\"purple\", linestyle=\":\")\n",
        "plt.plot(x, p_5(x), label=\"Grado 5\", color=\"brown\", linestyle=\"-\")\n",
        "\n",
        "plt.title(\"f(x)=e^x cos(x) - Analisis Numerico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.axhline(0, color=\"gray\", linewidth=0.8, linestyle=\"-\")\n",
        "plt.axvline(0, color=\"gray\", linewidth=0.8, linestyle=\"-\")\n",
        "plt.grid(True, linestyle='--', linewidth=0.5)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "e6628d4e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### b) Usar \\$P_5(0.5)\\$ para aproximar \\$f(0.5)\\$.\n"
      ],
      "id": "61e683a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.exp(x) * np.cos(x)\n",
        "\n",
        "# Polinomio de grado 5 \n",
        "def p5_mod(x):\n",
        "    return 1 + x - (x**3)/3 - (x**4)/6 - (x**5)/30\n",
        "\n",
        "x_val = 0.5\n",
        "aprox = p5_mod(x_val)\n",
        "valor_real = f(x_val)\n",
        "error_abs = abs(valor_real - aprox)\n",
        "\n",
        "print(f\"p5_mod({x_val}) = {aprox:.6f}\")\n",
        "print(f\"f({x_val}) = {valor_real:.15f}\")\n",
        "print(f\"Error absoluto: {error_abs:.14e}\")"
      ],
      "id": "7a82029d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<div>\n",
        "\n",
        "#### *c) Encontrar una cota superior para el error* $|f(0.5)-P_5(0.5)|$\n",
        "\n",
        "</div>\n"
      ],
      "id": "0e4ad504"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.exp(x) * np.cos(x)\n",
        "def P_5(x):\n",
        "    return 1 + x - (x**3)/3 - (x**4)/6 - (x**5)/30\n",
        "\n",
        "x_val = 0.5\n",
        "aprox = P_5(x_val)\n",
        "valor_real = f(x_val)\n",
        "cota = 132 / 720\n",
        "\n",
        "print(f\"La cota superior para el error es {cota}\")\n",
        "print(f\"La diferencia |f(0.5)-P_5(0.5)| = {np.abs(valor_real - aprox)}\")\n",
        "print(f\"¿La diferencia es menor que la cota superior? {np.abs(valor_real - aprox) < cota}\")"
      ],
      "id": "84d1cd63",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Consideremos los siguientes puntos en $\\mathbb{R}^2$:\n",
        "\n",
        "::: {#exr-tarea2_2}\n",
        "\\begin{equation}\n",
        "\\begin{array}{l|c|c|c|c|} \n",
        "\\text{x} & 0 & 1 & 2 & 3 \\\\\n",
        "\\hline \\text{y} & y_0 & y_1 & y_2 & y_3  \n",
        "\\end{array}\n",
        "\\end{equation}\n",
        "\n",
        "a)  Encontrar y graficar los polinomios base para el polinomio de Lagrange que contiene a los puntos.\n"
      ],
      "id": "de0c227d"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "# Nuevos puntos de interpolación\n",
        "val_x = [-1, 0.5, 2, 4]\n",
        "val_y = [3, -2, 5, -1]\n",
        "\n",
        "# Polinomios base de Lagrange \n",
        "L1 = lambda x: (x-val_x[1])*(x-val_x[2])*(x-val_x[3])/((val_x[0]-val_x[1])*(val_x[0]-val_x[2])*(val_x[0]-val_x[3]))\n",
        "L2 = lambda x: (x-val_x[0])*(x-val_x[2])*(x-val_x[3])/((val_x[1]-val_x[0])*(val_x[1]-val_x[2])*(val_x[1]-val_x[3]))\n",
        "L3 = lambda x: (x-val_x[0])*(x-val_x[1])*(x-val_x[3])/((val_x[2]-val_x[0])*(val_x[2]-val_x[1])*(val_x[2]-val_x[3]))\n",
        "L4 = lambda x: (x-val_x[0])*(x-val_x[1])*(x-val_x[2])/((val_x[3]-val_x[0])*(val_x[3]-val_x[1])*(val_x[3]-val_x[2]))\n",
        "\n",
        "xnew = np.linspace(-2, 5, 500)\n",
        "x_zeros = np.zeros(len(val_x))\n",
        "x_ones = np.ones(len(val_x))\n",
        "\n",
        "plt.figure(figsize=(9,5))\n",
        "plt.plot(xnew, L1(xnew), label=\"L1\", color=\"teal\", linestyle=\"-\")\n",
        "plt.plot(xnew, L2(xnew), label=\"L2\", color=\"orange\", linestyle=\"--\")\n",
        "plt.plot(xnew, L3(xnew), label=\"L3\", color=\"purple\", linestyle=\"-.\")\n",
        "plt.plot(xnew, L4(xnew), label=\"L4\", color=\"crimson\", linestyle=\":\")\n",
        "\n",
        "plt.scatter(val_x, x_zeros, c=\"navy\", marker=\"s\", label=\"x zeros\")\n",
        "plt.scatter(val_x, x_ones, c=\"limegreen\", marker=\"^\", label=\"x ones\")\n",
        "\n",
        "plt.title(\"Polinomios base de Lagrange Analisis Numerico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"L(x)\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "9de8a9d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "b)  Calcular y graficar el polinomio de Lagrange.\n"
      ],
      "id": "fc40da77"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "# Usando los val_x, val_y y L1, L2, L3, L4 definidos previamente\n",
        "\n",
        "# Polinomio interpolador \n",
        "p_mod = lambda x: val_y[0]*L1(x) + val_y[1]*L2(x) + val_y[2]*L3(x) + val_y[3]*L4(x)\n",
        "\n",
        "plt.figure(figsize=(9, 5))\n",
        "plt.plot(xnew, p_mod(xnew), label=\"Polinomio Interpolador\", color=\"darkmagenta\", linewidth=2)\n",
        "plt.scatter(val_x, val_y, color=\"darkcyan\", s=70, marker=\"D\", label=\"Puntos de Datos\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.7)\n",
        "plt.title(\"Interpolación Polinómica con Bases de Lagrange Análisis Numérico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"p(x)\")\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "f0091421",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {#def-errores}\n",
        "Supongamos que $p^*$ es una aproximación de $p$. El **error real** es $p-p^*$, el **error absoluto** es $|p-p^*|$ y el error relativo es\n",
        "\n",
        "\\begin{equation}\n",
        "\\frac{|p-p^*|}{|p|},\n",
        "\\end{equation}\n",
        "\n",
        "siempre y cuando $p\\neq 0$.\n",
        ":::\n",
        "\n",
        "::::::::: {#exr-tarea2_3}\n",
        "En cada inciso considera la función de valores reales y realiza lo siguiente:\n",
        "\n",
        "i.  Grafica los polinomios interpolantes de Lagrange con los puntos dados y aproxima el valor de la función y la derivada en el punto solicitado.\n",
        "\n",
        "ii. Grafica los splines cúbicos con frontera natural para los puntos dados y aproxima el valor de la función y la derivada en el punto solicitado.\n",
        "\n",
        "iii. Grafica los splines cúbicos con frontera condicionada para los puntos dados y aproxima el valor de la función y la derivada en el punto solicitado.\n",
        "\n",
        "En cada caso calcula el error real, el absoluto y el relativo.\n",
        "\n",
        "a)  $f(x)=e^{2x}$. Puntos: $x_0=0, x_1=0.25, x_2=0.5, x_3=0.75$. Aproximar $f(0.43)$ y $f'(0.43)$.\n"
      ],
      "id": "0e8bbca7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from scipy.interpolate import lagrange, CubicSpline\n",
        "\n",
        "# Definición de la función y su derivada\n",
        "f = lambda x: np.exp(2 * x)\n",
        "f_der = lambda x: 2 * np.exp(2 * x)\n",
        "\n",
        "# Nodos de interpolación\n",
        "x = np.array([0, 0.25, 0.5, 0.75])\n",
        "y = f(x)\n",
        "\n",
        "# Polinomio de Lagrange\n",
        "poli_lagrange = lagrange(x, y)\n",
        "\n",
        "# Splines cúbicos\n",
        "poli_spline_nat = CubicSpline(x, y, bc_type='natural')\n",
        "poli_spline_cond = CubicSpline(x, y, bc_type=((1, f_der(x[0])), (1, f_der(x[-1]))))\n",
        "\n",
        "# Valores para graficar\n",
        "x_vals = np.linspace(-0.5, 1, 500)\n",
        "\n",
        "plt.figure(figsize=(9, 5))\n",
        "plt.plot(x_vals, poli_lagrange(x_vals), label=\"Lagrange\", color=\"darkblue\", linestyle=\"--\", linewidth=2)\n",
        "plt.plot(x_vals, poli_spline_nat(x_vals), label=\"Spline Natural\", color=\"darkorange\", linestyle=\"-.\", linewidth=2)\n",
        "plt.plot(x_vals, poli_spline_cond(x_vals), label=\"Spline Condicionado\", color=\"forestgreen\", linestyle=\":\", linewidth=2)\n",
        "plt.scatter(x, y, color=\"black\", zorder=5, label=\"Nodos\", marker=\"o\", s=50)\n",
        "\n",
        "x_aprox = 0.43\n",
        "plt.axvline(x_aprox, color=\"magenta\", linestyle=\"--\", linewidth=1.5, label=f\"x = {x_aprox}\")\n",
        "\n",
        "plt.title(r\"Interpolaciones de $f(x) = e^{2x}$ Análisis Numerico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()\n"
      ],
      "id": "638f5fbe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Aproximación del valor de la función\n"
      ],
      "id": "ee07a159"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x_aprox = 0.43\n",
        "\n",
        "# Aproximación de la función en x_aprox\n",
        "f_lagrange = poli_lagrange(x_aprox)\n",
        "f_der_lagrange = np.polyder(poli_lagrange)(x_aprox)\n",
        "\n",
        "f_snatural = poli_spline_nat(x_aprox)\n",
        "f_der_snatural = poli_spline_nat.derivative()(x_aprox)\n",
        "\n",
        "f_scondicionado = poli_spline_cond(x_aprox)\n",
        "f_der_scondicionado = poli_spline_cond.derivative()(x_aprox)\n",
        "\n",
        "print(f\"Aproximación del valor de la función cuando x={x_aprox}:\")\n",
        "print(f\"Lagrange: {f_lagrange}\")\n",
        "print(f\"Spline Natural: {f_snatural}\")\n",
        "print(f\"Spline Condicionado: {f_scondicionado}\")\n",
        "print(\"-----------------------------------------\")\n",
        "print(f\"Aproximación de la derivada de la función cuando x={x_aprox}:\")\n",
        "print(f\"Lagrange: {f_der_lagrange}\")\n",
        "print(f\"Spline Natural: {f_der_snatural}\")\n",
        "print(f\"Spline Condicionado: {f_der_scondicionado}\")"
      ],
      "id": "c72f6a3f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<div>\n",
        "\n",
        "*Calculo de los errores real, absoluto y relativo*\n",
        "\n",
        "</div>\n"
      ],
      "id": "e123ba34"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "error_real = f(x_aprox) - np.array([f_lagrange, f_SNatural, f_SCondicionado])\n",
        "error_absoluto = np.abs(error_real)\n",
        "error_relativo = (error_absoluto/f(x_aprox))\n",
        "\n",
        "print(f\"Error Real= {error_real}\")\n",
        "print(f\"Error Absoluto= {error_absoluto}\")\n",
        "print(f\"Error Relativo= {error_relativo}\")"
      ],
      "id": "1002a01d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Inciso B $f(x)=x\\,cos\\,x-3x$. Puntos: $x_0=0, x_1=0.5, x_2=1, x_3=1.5$. Aproximar $f(0.8)$ y $f'(0.8)$.\n"
      ],
      "id": "55af9873"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: x * np.cos(x) - 3 * x\n",
        "f_der = lambda x: -x * np.sin(x) + np.cos(x) - 3\n",
        "\n",
        "# Nodos de interpolación\n",
        "x_nodes = np.array([0, 0.5, 1, 1.5])\n",
        "y_nodes = f(x_nodes)\n",
        "\n",
        "# Construcción de interpoladores\n",
        "lagrange_poly = lagrange(x_nodes, y_nodes)\n",
        "spline_natural = CubicSpline(x_nodes, y_nodes, bc_type='natural')\n",
        "spline_cond = CubicSpline(x_nodes, y_nodes, bc_type=((1, f_der(x_nodes[0])), (1, f_der(x_nodes[-1]))))\n",
        "\n",
        "# Valores para graficar\n",
        "x_vals = np.linspace(-0.5, 2, 500)\n",
        "\n",
        "plt.figure(figsize=(9, 5))\n",
        "plt.plot(x_vals, lagrange_poly(x_vals), label='Lagrange', color='navy', linestyle='--', linewidth=2)\n",
        "plt.plot(x_vals, spline_natural(x_vals), label='Spline Natural', color='darkorange', linestyle='-.', linewidth=2)\n",
        "plt.plot(x_vals, spline_cond(x_vals), label='Spline Condicionado', color='seagreen', linestyle=':', linewidth=2)\n",
        "plt.scatter(x_nodes, y_nodes, color='black', s=50, label='Nodos', zorder=5)\n",
        "\n",
        "x_aprox = 0.8\n",
        "plt.axvline(x_aprox, color='magenta', linestyle='--', linewidth=1.5, label=f'x = {x_aprox}')\n",
        "\n",
        "plt.title(r'Interpolaciones de $f(x) = x \\cos(x) - 3x$ Analisis numerico')\n",
        "plt.xlabel('x')\n",
        "plt.ylabel('y')\n",
        "plt.grid(True, linestyle='--', alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "e57e02b0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<div>\n",
        "\n",
        "Aproximación del valor de la función\n"
      ],
      "id": "b55a6ad6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x_aprox = 0.8\n",
        "\n",
        "# Aproximación de la función en x_aprox\n",
        "f_lagrange = lagrange_poly(x_aprox)\n",
        "# Para derivada del polinomio de Lagrange\n",
        "f_der_lagrange = np.polyder(lagrange_poly)(x_aprox)\n",
        "\n",
        "f_snatural = spline_natural(x_aprox)\n",
        "f_der_snatural = spline_natural.derivative()(x_aprox)\n",
        "\n",
        "f_scond = spline_cond(x_aprox)\n",
        "f_der_scond = spline_cond.derivative()(x_aprox)\n",
        "\n",
        "print(f\"Aproximación del valor de la función cuando x={x_aprox}:\")\n",
        "print(f\"Lagrange: {f_lagrange}\")\n",
        "print(f\"Spline Natural: {f_snatural}\")\n",
        "print(f\"Spline Condicionado: {f_scond}\")\n",
        "print(\"-----------------------------------------\")\n",
        "print(f\"Aproximación de la derivada de la función cuando x={x_aprox}:\")\n",
        "print(f\"Lagrange: {f_der_lagrange}\")\n",
        "print(f\"Spline Natural: {f_der_snatural}\")\n",
        "print(f\"Spline Condicionado: {f_der_scond}\")"
      ],
      "id": "96eba57e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</div>\n",
        "\n",
        "<div>\n",
        "\n",
        "<div>\n",
        "\n",
        "*Calculo de los errores real, absoluto y relativo*\n"
      ],
      "id": "1c9800ff"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Valor exacto de la función en x_aprox\n",
        "valor_real = f(x_aprox)\n",
        "\n",
        "# Vector con las aproximaciones \n",
        "aproximaciones = np.array([f_lagrange, f_snatural, f_scond])\n",
        "\n",
        "# Cálculo de errores\n",
        "error_real = valor_real - aproximaciones\n",
        "error_absoluto = np.abs(error_real)\n",
        "error_relativo = error_absoluto / np.abs(valor_real)\n",
        "\n",
        "print(f\"Error Real= {error_real}\")\n",
        "print(f\"Error Absoluto= {error_absoluto}\")\n",
        "print(f\"Error Relativo= {error_relativo}\")"
      ],
      "id": "680034eb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</div>\n",
        "\n",
        "</div>\n",
        "\n",
        "Inciso C $f(x)=log(e^x+2)$. Puntos: $x_0=-2, x_1=-1, x_2=0, x_3=1, x_4=2$. Aproximar $f(0.5)$ y $f'(0.5)$.\n"
      ],
      "id": "bd7fa30a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| fig-align: \"center\"\n",
        "\n",
        "\n",
        "f = lambda x: np.log(np.exp(x)+2)\n",
        "f_der = lambda x: np.exp(x)/(np.exp(x)+2)\n",
        "x = np.arange(-2,3)\n",
        "y = f(x)\n",
        "\n",
        "poli_lagrange = lagrange(x,y)\n",
        "poli_spnat = CubicSpline(x,y, bc_type= \"natural\")\n",
        "poli_spcond = CubicSpline(x,y, bc_type= ((1,f_der(x[0])), (1,f_der(x[-1]))))\n",
        "\n",
        "x_values = np.linspace(-2.5, 2.5, 500)\n",
        "\n",
        "plt.figure(figsize=(8,5))\n",
        "plt.plot(x_values, poli_lagrange(x_values), label=\"Lagrange\")\n",
        "plt.plot(x_values, poli_spnat(x_values), label=\"Spline Natural\")\n",
        "plt.plot(x_values, poli_spcond(x_values), label=\"Spline Cond\")\n",
        "plt.plot(x, y,'o', label=\"Nodos\")\n",
        "plt.grid()\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "6664b5f9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<div>\n",
        "\n",
        "<div>\n",
        "\n",
        "Aproximación del valor de la función\n"
      ],
      "id": "cd5a002d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "_aprox = 0.5 \n",
        "\n",
        "f_lagrange = poli_lagrange(x_aprox)\n",
        "f_der_lagrange = np.polyder(poli_lagrange)(x_aprox)\n",
        "\n",
        "f_snatural = poli_spnat(x_aprox)\n",
        "f_der_snatural = poli_spnat.derivative()(x_aprox)\n",
        "\n",
        "f_scond = poli_spcond(x_aprox)\n",
        "f_der_scond = poli_spcond.derivative()(x_aprox)\n",
        "\n",
        "print(f\"Aproximación del valor de la función cuando x={x_aprox}:\")\n",
        "print(f\"Lagrange: {f_lagrange}\")\n",
        "print(f\"Spline Natural: {f_snatural}\")\n",
        "print(f\"Spline Condicionado: {f_scond}\")\n",
        "print(\"-----------------------------------------\")\n",
        "print(f\"Aproximación de la derivada de la función cuando x={x_aprox}:\")\n",
        "print(f\"Lagrange: {f_der_lagrange}\")\n",
        "print(f\"Spline Natural: {f_der_snatural}\")\n",
        "print(f\"Spline Condicionado: {f_der_scond}\")"
      ],
      "id": "ba8a5ed4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</div>\n",
        "\n",
        "Cálculo de errores\n"
      ],
      "id": "3c64f781"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "valor_real = f(x_aprox)\n",
        "\n",
        "# Vector con las aproximaciones \n",
        "aproximaciones = np.array([f_lagrange, f_SNatural, f_SCondicionado])\n",
        "\n",
        "# Cálculo de errores\n",
        "error_real = valor_real - aproximaciones\n",
        "error_absoluto = np.abs(error_real)\n",
        "error_relativo = error_absoluto / np.abs(valor_real)\n",
        "\n",
        "print(f\"Error Real= {error_real}\")\n",
        "print(f\"Error Absoluto= {error_absoluto}\")\n",
        "print(f\"Error Relativo= {error_relativo}\")"
      ],
      "id": "fe7aee71",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</div>\n"
      ],
      "id": "bb52d760"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "poli_lagrange(0.5)\n",
        "poli_spnat(0.5)\n",
        "poli_spcond(0.5)\n",
        "f(0.5)"
      ],
      "id": "ddd27056",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::::::::\n",
        "\n",
        "::: {#exr-tarea2_4}\n",
        "Se sospecha que las elevadas concentraciones de tanina en las hojas de los robles maduros inhiben el crecimiento de las larvas de la polilla invernal (*Operophtera bromata L. Geometridae*) que tanto dañan a los árboles en algunos años. La tabla anexa contiene el peso promedio de dos muestras de larva, tomadas en los primeros 28 días después de nacimiento. La primera muestra se crió en hojas de robles jóvenes, mientras que la segunda lo hizo en hojas maduras del mismo árbol.\n",
        "\n",
        "a)  Usa la interpolación polinomial (Lagrange) para aproximar la curva del peso promedio de cada muestra.\n",
        "\n",
        "b)  Usa splines cúbicos para aproximar la curva del peso promedio de cada muestra.\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{array}{l|c|c|c|c|c|c|r} \n",
        "\\text{Día} & 0 & 6 & 10 & 13 & 17 & 20 & 28 \\\\\n",
        "\\hline \\text{Peso promedio muestra 1 (mg)} & 6.67 & 17.33 & 42.67 & 37.33 & 30.10 & 29.31 & 28.74 \\\\\n",
        "\\text{Peso promedio muestra 2 (mg)} & 6.67 & 16.11 & 18.89 & 15.00 & 10.56 & 9.44 & 8.89\n",
        "\\end{array}\n",
        "\\end{equation}\n",
        "\n",
        "Muestra 1\n"
      ],
      "id": "deae5b1d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x_data = np.array([0, 6, 10, 13, 17, 20, 28])\n",
        "y_data = np.array([6.67, 17.33, 42.67, 37.33, 30.10, 29.31, 28.74])\n",
        "\n",
        "# Polinomio de Lagrange\n",
        "poly_lagrange = lagrange(x_data, y_data)\n",
        "\n",
        "# Spline cúbico natural (usando los mismos nodos y valores)\n",
        "spline_cubico = CubicSpline(x_data, y_data, bc_type=\"natural\")\n",
        "\n",
        "# Nuevos puntos para evaluar las interpolaciones\n",
        "x_interp = np.linspace(0, 28, 500)\n",
        "\n",
        "plt.figure(figsize=(9,5))\n",
        "plt.plot(x_interp, poly_lagrange(x_interp), color=\"steelblue\", label=\"Lagrange\")\n",
        "plt.plot(x_interp, spline_cubico(x_interp), color=\"deeppink\", label=\"Spline cúbico natural\")\n",
        "plt.scatter(x_data, y_data, color=\"darkred\", marker=\"o\", label=\"Nodos\")\n",
        "\n",
        "plt.title(\"Curva de peso promedio de la muestra 1 Análisis Numerico\")\n",
        "plt.xlabel(\"Día\")\n",
        "plt.ylabel(\"Peso Promedio (mg)\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "8e723132",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Muestra 2\n"
      ],
      "id": "590d5fac"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Datos de la muestra 2\n",
        "x = np.array([0, 6, 10, 13, 17, 20, 28])\n",
        "y = np.array([6.67, 16.11, 18.89, 15.00, 10.56, 9.44, 8.89])\n",
        "\n",
        "# Polinomio de Lagrange\n",
        "polinomio = lagrange(x, y)\n",
        "\n",
        "# Spline cúbico natural usando los mismos nodos y valores\n",
        "spline_cubico = CubicSpline(x, y, bc_type=\"natural\")\n",
        "\n",
        "# Nuevos puntos para evaluar las interpolaciones\n",
        "x_new = np.linspace(0, 28, 500)\n",
        "\n",
        "plt.figure(figsize=(8,5))\n",
        "plt.plot(x_new, polinomio(x_new), color=\"red\", label=\"Lagrange\")\n",
        "plt.plot(x_new, spline_cubico(x_new), color=\"sandybrown\", label=\"Spline cúbico\")\n",
        "plt.scatter(x, y, color=\"black\", marker=\"o\", label=\"Nodos\")\n",
        "\n",
        "plt.title(\"Curva de peso promedio de la muestra 2 Análisis Numerico\")\n",
        "plt.xlabel(\"Díass\")\n",
        "plt.ylabel(\"Peso Promedio (mg)\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "ee7538aa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {#exr-tarea2_5}\n",
        "Considera la siguiente tabla de datos para el agua:\n",
        "\n",
        "\\begin{equation}\n",
        "\\begin{array}{|l|c|c|c|c|c|} \n",
        "\\hline \\text{T(°C)} & 50 & 60 & 65 & 75 & 80\\\\\n",
        " \\text{$\\rho (kg/m^3)$} & 988 & 985.7 & 980.5 & 974.8 & 971.6  \\\\\n",
        "\\hline\n",
        "\\end{array}\n",
        "\\end{equation}\n",
        "\n",
        "Donde $T$ es la temperatura y $\\rho$ es la densidad.\n",
        "\n",
        "a)  Hacer la representación gráfica del spline cúbico y compararlo con el polinomio interpolante $P_4(x)$.\n"
      ],
      "id": "8db2b1df"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = np.array([50, 60, 65, 75, 80])\n",
        "y = np.array([988, 985.7, 980.5, 974.8, 971.6])\n",
        "\n",
        "# Polinomio de Lagrange\n",
        "polinomio = lagrange(x, y)\n",
        "\n",
        "# Spline cúbico natural con los mismos nodos\n",
        "spline_cubico = CubicSpline(x, y, bc_type=\"natural\")\n",
        "\n",
        "# Puntos para evaluar las interpolaciones\n",
        "x_new = np.linspace(50, 80, 500)\n",
        "\n",
        "# Graficar\n",
        "plt.figure(figsize=(8,5))\n",
        "plt.plot(x_new, polinomio(x_new), color=\"blue\", label=\"Lagrange\")\n",
        "plt.plot(x_new, spline_cubico(x_new), color=\"navy\", label=\"Spline cúbico\")\n",
        "plt.scatter(x, y, color=\"darkred\", label=\"Nodos\", zorder=5)\n",
        "\n",
        "plt.title(\"Spline Cúbico y Polinomio Interpolante Análisis Numérico\")\n",
        "plt.xlabel(\"Temperatura (°C)\")\n",
        "plt.ylabel(\"Densidad (kg/m³)\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "d502a167",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "a)  Aproximar la densidad para $T=63 °C$ y también la derivada.\n"
      ],
      "id": "fe7f17e5"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "T_aprox = 63\n",
        "\n",
        "p_lagrange = polinomio(T_aprox)\n",
        "p_der_lagrange = np.polyder(polinomio)(T_aprox)\n",
        "\n",
        "p_sp = my_spline(T_aprox)\n",
        "p_der_sp = my_spline.derivative()(T_aprox)\n",
        "\n",
        "print(f\"Aproximación de la densidad cuando T=63°C:\")\n",
        "print(f\"Lagrange: {p_lagrange}\")\n",
        "print(f\"Spline Cúbico: {p_sp}\")\n",
        "print(\"--------------------------------\")\n",
        "print(f\"Aproximación de la derivada cuando T=63°C:\")\n",
        "print(f\"Lagrange: {p_der_lagrange}\")\n",
        "print(f\"Spline Cúbico: {p_der_sp}\")"
      ],
      "id": "fd98d00f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {#exr-tarea2_6}\n",
        "Llevar a cabo lo siguiente:\n",
        "\n",
        "i.  Genera una sucesión desde 0 hasta 10 con la función `np.arange` y asígnalo a la variable $x$.\n",
        "\n",
        "ii. Del conjunto $\\{-25, -24, \\dots, 24, 25\\}\\subset\\mathbb{Z}$ toma una muestra con reemplazo que tenga la misma cantidad de elementos de $x$ y asígnalo a la variable $y$ (utilizar la función `np.random.choice`).\n",
        "\n",
        "iii. Encuentra el spline cúbico que que contiene a los puntos generados\n"
      ],
      "id": "b9743127"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = np.arange(0, 11)\n",
        "y = np.random.choice(np.arange(-25, 26), len(x))\n",
        "\n",
        "poli_spnat = CubicSpline(x, y, bc_type=\"natural\")\n",
        "\n",
        "x_values = np.linspace(-0.5, 12, 500)\n",
        "\n",
        "# Graficar\n",
        "plt.figure(figsize=(8,5))\n",
        "plt.plot(x_values, poli_spnat(x_values), label=\"Spline Natural\", color=\"red\")\n",
        "plt.scatter(x, y, label=\"Nodos\", color=\"navy\", zorder=5)\n",
        "\n",
        "plt.title(\"Interpolación con Spline Cúbico Natural (x de 0 a 10) Análisis numérico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.6)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "36caa848",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {#exr-tarea2_7}\n",
        "Construye los splines cúbicos condicionados en $n$ nodos, donde $n= 4,5, 10, 20$ para las siguientes funciones en el intervalo dado. Con el de $n=20$ nodos calcula la diferencia máxima entre la función y el spline tomando 500 puntos distribuidos de manera uniforme en el intervalo.\n",
        "\n",
        "a)  $f(x) = e^{2x}\\, cos 3x$, $[0,2]$.\n"
      ],
      "id": "98e030c2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.exp(2*x)*np.cos(3*x)\n",
        "f_der = lambda x: -3*np.exp(2*x)*np.sin(3*x) + 2*np.exp(2*x)*np.cos(3*x)\n",
        "\n",
        "n_values = [4, 5, 10, 20]\n",
        "a, b = 0, 2\n",
        "\n",
        "x_new = np.linspace(a, b, 500)\n",
        "\n",
        "plt.figure(figsize=(9, 4))\n",
        "\n",
        "for n in n_values:\n",
        "  \n",
        "    x_nodos = np.linspace(a, b, n)\n",
        "    y_nodos = f(x_nodos)\n",
        "    \n",
        "    poli_spCond = CubicSpline(x_nodos, y_nodos, bc_type=((1, f_der(a)), (1, f_der(b))))\n",
        "    y_sp = poli_spCond(x_new)\n",
        "    \n",
        "    plt.plot(x_new, y_sp, label=f\"Spline n={n}\")\n",
        "    plt.plot(x_nodos, y_nodos, 'o', color='blue')\n",
        "\n",
        "plt.title(\"Splines Cúbicos Condicionados f(x)=e^(2x)cos(3x) Análisis Numerico \")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.grid(True, linestyle='--', alpha=0.7)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "6b82cf73",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "a)  $f(x) = sen(log\\,x)$, $[1,10]$.\n"
      ],
      "id": "57853e33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.sin(np.log(x))\n",
        "f_der = lambda x: (1/x) * np.cos(np.log(x))\n",
        "\n",
        "# Valores de n para número de nodos\n",
        "n_val = [4, 5, 10, 20]\n",
        "\n",
        "# Intervalo de interpolación\n",
        "a, b = 1, 10\n",
        "\n",
        "# Puntos para graficar la spline suavemente\n",
        "x_plot = np.linspace(a, b, 500)\n",
        "\n",
        "# Colores personalizados para cada spline\n",
        "colores = ['darkorange', 'mediumseagreen', 'royalblue', 'crimson']\n",
        "\n",
        "plt.figure(figsize=(9, 4))\n",
        "\n",
        "# Graficar la función original como referencia\n",
        "plt.plot(x_plot, f(x_plot), \"--\", color=\"cyan\", label=\"Función original\")\n",
        "\n",
        "for i, n in enumerate(n_val):\n",
        "    x_nodos = np.linspace(a, b, n)\n",
        "    y_nodos = f(x_nodos)\n",
        "    \n",
        "    poli_spCond = CubicSpline(x_nodos, y_nodos, bc_type=((1, f_der(a)), (1, f_der(b))))\n",
        "    \n",
        "    plt.plot(x_plot, poli_spCond(x_plot), label=f\"Spline n={n}\", color=colores[i], linewidth=2)\n",
        "    plt.scatter(x_nodos, y_nodos, color=colores[i], edgecolor='black', s=60, label=\"Nodos\" if i == 0 else \"\")\n",
        "\n",
        "plt.title(\"Splines cúbicos condicionados para f(x) = sen(log(x)) Análisis Numerico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.7)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "bc6bc51f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "a)  $f(x) = e^{x}+e^{-x}$, $[0,3]$.\n"
      ],
      "id": "e535ad4f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.exp(x) + np.exp(-x)\n",
        "f_der = lambda x: np.exp(x) - np.exp(-x)\n",
        "\n",
        "n_values = [4, 5, 10, 20]\n",
        "a, b = 0, 3\n",
        "\n",
        "x_new = np.linspace(a, b, 500)\n",
        "\n",
        "# Colores para cada spline\n",
        "colors = ['darkorange', 'mediumseagreen', 'royalblue', 'crimson']\n",
        "\n",
        "plt.figure(figsize=(9, 4))\n",
        "\n",
        "for i, n in enumerate(n_values):\n",
        "    x_nodos = np.linspace(a, b, n)\n",
        "    y_nodos = f(x_nodos)\n",
        "    \n",
        "    poli_spCond = CubicSpline(x_nodos, y_nodos, bc_type=((1, f_der(a)), (1, f_der(b))))\n",
        "    y_sp = poli_spCond(x_new)\n",
        "    \n",
        "    plt.plot(x_new, y_sp, label=f\"Spline n={n}\", color=colors[i], linewidth=2)\n",
        "    plt.scatter(x_nodos, y_nodos, color=colors[i], edgecolor='black', s=50, label=\"Nodos\" if i == 0 else \"\")\n",
        "\n",
        "plt.title(\"Splines Cúbicos Condicionados f(x)=e^(x) + e^(-x) Análisis Numérico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.7)\n",
        "plt.legend()\n",
        "plt.show()\n"
      ],
      "id": "985fcddd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "a)  $f(x) = cos \\,x+sen\\,x$, $[0,2\\pi]$.\n"
      ],
      "id": "44940de9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x : np.cos(x) + np.sin(x)\n",
        "f_der = lambda x : -np.sin(x) + np.cos(x)\n",
        "\n",
        "n_values = [4, 5, 10, 20]\n",
        "a, b = 0, 2*np.pi\n",
        "\n",
        "x_new = np.linspace(a, b, 500)\n",
        "\n",
        "# Lista de colores para las curvas y nodos\n",
        "colors = ['darkorange', 'mediumseagreen', 'royalblue', 'crimson']\n",
        "\n",
        "plt.figure(figsize=(9, 4))\n",
        "\n",
        "for i, n in enumerate(n_values):\n",
        "    x_nodos = np.linspace(a, b, n)\n",
        "    y_nodos = f(x_nodos)\n",
        "    \n",
        "    poli_spCond = CubicSpline(x_nodos, y_nodos, bc_type=((1, f_der(a)), (1, f_der(b))))\n",
        "    y_sp = poli_spCond(x_new)\n",
        "    \n",
        "    plt.plot(x_new, y_sp, label=f\"Spline n={n}\", color=colors[i], linewidth=2)\n",
        "    plt.scatter(x_nodos, y_nodos, color=colors[i], edgecolor='black', s=50, label=\"Nodos\" if i == 0 else \"\")\n",
        "\n",
        "plt.title(\"Splines Cúbicos f(x)= cos(x) + sin (x) Análisis Numérico\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.grid(True, linestyle=\"--\", alpha=0.7)\n",
        "plt.legend()\n",
        "plt.show()"
      ],
      "id": "4e7c587a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = lambda x: np.cos(x) + np.sin(x)\n",
        "f_der = lambda x: -np.sin(x) + np.cos(x)\n",
        "\n",
        "# Intervalo\n",
        "a, b = 0, 2 * np.pi\n",
        "\n",
        "# Número de nodos\n",
        "n = 20\n",
        "\n",
        "# Nodos equiespaciados y valores de la función en ellos\n",
        "x_nodos = np.linspace(a, b, n)\n",
        "y_nodos = f(x_nodos)\n",
        "\n",
        "# Construcción del spline cúbico condicionado (clamped)\n",
        "poli_spCond_20 = CubicSpline(x_nodos, y_nodos, bc_type=((1, f_der(a)), (1, f_der(b))))\n",
        "\n",
        "# Puntos para evaluación fina\n",
        "x = np.linspace(a, b, 500)\n",
        "y_val_real = f(x)\n",
        "y_val_spline = poli_spCond_20(x)\n",
        "\n",
        "# Calcular la diferencia máxima absoluta\n",
        "difd = np.max(np.abs(y_val_real - y_val_spline))\n",
        "\n",
        "print(f\"Diferencia máxima entre f(x) y el spline con n=20: {difd:.6f}\")\n",
        "\n",
        "# Opcional: graficar para visualizar la aproximación y el error\n",
        "plt.figure(figsize=(8,5))\n",
        "plt.plot(x, y_val_real, label='Función original', color='blue')\n",
        "plt.plot(x, y_val_spline, label='Spline cúbico n=20', linestyle='--', color='red')\n",
        "plt.scatter(x_nodos, y_nodos, color='black', label='Nodos')\n",
        "plt.title('Comparación función original y spline cúbico condicionado Análisis Numerico')\n",
        "plt.xlabel('x')\n",
        "plt.ylabel('y')\n",
        "plt.legend()\n",
        "plt.grid(True, linestyle='--', alpha=0.7)\n",
        "plt.show()"
      ],
      "id": "ec042745",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::"
      ],
      "id": "9eaa160b"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}